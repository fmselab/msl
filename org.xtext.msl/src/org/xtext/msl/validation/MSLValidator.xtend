/*
 * generated by Xtext 2.13.0
 */
package org.xtext.msl.validation

import org.eclipse.xtext.validation.Check
import org.xtext.msl.mSL.ConcreteGroup
import org.xtext.msl.mSL.Pattern
import org.xtext.msl.mSL.AbstractPattern
import org.xtext.msl.mSL.MSLPackage
import org.xtext.msl.mSL.Configuration
import org.xtext.msl.mSL.AbstractGroup
import java.util.Map
import java.util.HashMap
import org.xtext.msl.mSL.Interaction

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MSLValidator extends AbstractMSLValidator {
	public static val MULTIPLE_CONCRETIZATION = 'multipleConcretization'
	public static val NO_CONCRETIZATION = 'noConcretization'
	public static val NOT_MATCHED_INTERACTION = 'notMatchedInteraction'
	int found
	boolean matched
	AbstractGroup startAbsGroup
	AbstractGroup endAbsGroup

	@Check
	def checkPattern(Pattern pattern) {
		for(g: pattern.absPattern.abstractGroups) {
			found = 0
			for(cg: pattern.groups) {
				if(cg.absGroup.name.equals(g.name)) {
					found++
				}
			}
			if(found == 0) {
				error('Group ' + g.name + ' has not been concretized', MSLPackage.Literals.PATTERN__NAME, MULTIPLE_CONCRETIZATION)
			}
			else if(found > 1) {
				error('Group '+ g.name + ' has been concretized more than once', MSLPackage.Literals.PATTERN__NAME, NO_CONCRETIZATION)
			}
		}
		for(s: pattern.absPattern.managedSystems) {
			found = 0
			for(ms: pattern.managedSystems) {
				if(ms.absSys.name.equals(s.name)) {
					found++
				}
			}
			if(found == 0) {
				error('System ' + s.name + ' has not been concretized', MSLPackage.Literals.PATTERN__NAME, MULTIPLE_CONCRETIZATION)
			}
			else if(found > 1) {
				error('System ' + s.name + ' has been concretized more than once', MSLPackage.Literals.PATTERN__NAME, NO_CONCRETIZATION)
			}
		}
	}
	
	@Check
	def checkInteraction(Interaction ci) {
		matched = false
		//now we assume that there is only one abstract group for each concrete group
		startAbsGroup = (ci.start.component.eContainer as ConcreteGroup).abstractGroups.get(0).absGroup
		endAbsGroup = (ci.end.component.eContainer as ConcreteGroup).abstractGroups.get(0).absGroup
		for(p: (ci.eContainer as Configuration).pattern) {
			for(ai: p.absPattern.interactions) {
				if(ci.start.component.type == ai.start.type.name &&
					ci.end.component.type == ai.end.type.name &&
					startAbsGroup == ai.start.type.eContainer &&
					endAbsGroup == ai.end.type.eContainer
				) {
					//println(ai.start.type)
					//println(ai.end.type)
					matched = true
				}
			}
		}
		if(!matched) {
			error('Interaction ' + ci + ' does not match any abstract interaction', MSLPackage.Literals.INTERACTION__START, NOT_MATCHED_INTERACTION)
			//error('Interaction ' + ci + ' does not match any abstract interaction', MSLPackage.Literals.INTERACTION, MSLPackage.Literals.INTERACTION__START)
		}
	}
}
