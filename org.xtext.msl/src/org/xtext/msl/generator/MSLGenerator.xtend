/**
 * Generated by Xtext 2.13.0
 * 
 * This generator allows you to create a .dot file
 * containing a complete DOT code for obtaining a 
 * graphical notation of you own MSL model.
 * 
 * @author: Emanuele Perico, Patrizia Scandurra
 * @version: 1.0
 * @date: 10th December 2019
 */
package org.xtext.msl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
/// Necessary import files for obtaining the graphical notation:
import org.xtext.msl.mSL.Specification
import org.xtext.msl.mSL.AbstractPattern
import org.xtext.msl.mSL.AbstractSystem
import org.xtext.msl.mSL.AbstractGroup
import org.xtext.msl.mSL.AbstractComponent
import org.xtext.msl.mSL.AbstractInteraction
import org.xtext.msl.mSL.Pattern
//import org.xtext.msl.mSL.SystemBinding > not used
import org.xtext.msl.mSL.GroupBinding
import org.xtext.msl.mSL.Configuration
//import org.xtext.msl.mSL.ConcreteSystem > not used
import org.xtext.msl.mSL.ConcreteGroup
import org.xtext.msl.mSL.ComponentInstance
import org.xtext.msl.mSL.Interaction

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MSLGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile(res.fileName,(res.contents.head as Specification).toDot)
	}
	
	/*
	 * - Leave comments outside the methods otherwise it will
	 *	 generate a blank line inside the generated DOT code.
	 * - All the code on a grey background will be
	 *	 written inside the generated DOT code.
	 * - The generated DOT code will respect the indentation
	 *	 given inside the generator's methods.
	 * - In Xtend:
	 * 		getAbsPattern.getDotAbsSubgraph
	 * 	 is the dual of the Java:
	 *		Specification spec = this;
	 *		AbstractPattern absPat = spec.getAbsPattern;
	 *		getDotAbsSubgraph(absPat);
	 *	 That is the way this generator is implemented.
	 * - There is no need to use lots of variables in Xtend.
	 *	 If needed, there are two types of them:
	 *		- val: for final fields and variables.
	 *		- var: for non-final fields and variables.
	 */
	
	/**
	 * Generates the complete DOT code for
	 * abstract/concrete pattern and configuration
	 */
	private def toDot(Specification it) '''
		digraph G {
			node [shape=square]
			edge [arrowhead=vee]
			rankdir=LR
			ranksep=0.5
			nodesep=0.5
			compound=true
			
			subgraph cluster0 {
				label=""
				
				«IF getAbsPattern !== null»
					«getAbsPattern.getDotAbsSubgraph»
				«ENDIF»
				
				«IF getPattern !== null»
					«FOR concrPattern : getPattern»
						«concrPattern.getDotConcrSubgraph»
					«ENDFOR»
				«ENDIF»
				
				«IF getConfiguration !== null»
					«getConfiguration.getDotConfigSubgraph»
				«ENDIF»
			}
		}
	'''
	
	
	/* **Methods for abstract patterns** */
	// Using dashed style for every element inside of it
	
	/**
	 * Generates the DOT code for an AbstractPattern
	 */
	private def getDotAbsSubgraph(AbstractPattern it) '''
		subgraph cluster_abstract {
			label="«getName»"
			style=dashed
			node [style=dashed]
			edge [style=dashed]
			
			«IF getManagedSystems !== null»
				«FOR managedSys : getManagedSystems»
					«managedSys.getDotAbsSystems»
				«ENDFOR»
			«ENDIF»
			
			«IF getAbstractGroups !== null»
				«FOR absGroups : getAbstractGroups»
					«absGroups.getDotAbsGroups»
				«ENDFOR»
			«ENDIF»
			
			«IF getInteractions !== null»
				«FOR absInteraction : getInteractions»
					«absInteraction.getDotAbsInteractions»
				«ENDFOR»
			«ENDIF»
		}
	'''
	
	/**
	 * Generates the DOT code for an AbstractSystem
	 */
	private def getDotAbsSystems(AbstractSystem it) '''
		AbsSys [shape=rectangle style=filled width=2 label="«getName»"]
	'''
	
	/**
	 * Generates the DOT code for an AbstractGroup
	 */
	/*
	 * To distinguish the same type of component contained
	 * in two different groups, the node ID is
	 * created as follows: grpName_componentName.
	 * For example: grp1_M and grp2_M.
	 */ 
	//
	private def getDotAbsGroups(AbstractGroup it) '''
		subgraph cluster_«getName» {
			label="«getName»"
			style="rounded, dashed"
			«IF getComponents !== null»
				«FOR absComponents : getComponents»
					«getName + "_" + absComponents.getDotAbsComponents»
				«ENDFOR»
			«ENDIF»
		}
	'''
	
	/**
	 * Generates the DOT code for an AbstractComponent
	 */
	private def getDotAbsComponents(AbstractComponent it)'''
		«getName» [label="«getName»"]
	'''
	
	/**
	 * Generates the DOT code for an AbstractInteraction
	 */
	/*
	 * First IF Statement: two cases -same or different AbstractGroup-, only
	 * 					   adds attribute CONSTRAINT for better visualization
	 * Second IF Statement: adding an edge between ManagedSystem and M component.
	 * Third IF Statement: addition of a "false" interaction between M and
	 *					   E just for the layout (specially in the Master-Slave case).
	 *					   This is set to invisible because there is no actual 
	 *					   interaction between component M and E.
	*/
	private def getDotAbsInteractions(AbstractInteraction it) '''
		«val absCompStart = getStart.getType»
		«val absGrpStart = absCompStart.eContainer as AbstractGroup»
		«val absCompEnd = getEnd.getType»
		«val absGrpEnd = absCompEnd.eContainer as AbstractGroup»
		«absGrpStart.getName + "_" + absCompStart.getName» -> «absGrpEnd.getName + "_" + absCompEnd.getName»
		«IF absGrpStart == absGrpEnd»
			[headlabel="«getHigh»" taillabel="«getLow»" labelfontcolor=blue]
		«ELSE»
			[headlabel="«getHigh»" taillabel="«getLow»" labelfontcolor=blue constraint=false]
		«ENDIF»
		«IF absCompStart.getName == 'M'»
			AbsSys -> «absGrpStart.getName + "_" + absCompStart.getName»
			[arrowhead=box lhead=cluster_«absGrpStart.getName» constraint=false]
		«ELSEIF absCompEnd.getName == 'M'»
			AbsSys -> «absGrpEnd.getName + "_" + absCompEnd.getName»
			[arrowhead=box lhead=cluster_«absGrpEnd.getName» constraint=false]
		«ENDIF»
		«IF absCompStart.getName == 'M'»
			«absGrpStart.getName + "_M"» -> «absGrpStart.getName + "_E"» [style=invis]
		«ELSEIF absCompEnd.getName == 'M'»
			«absGrpEnd.getName + "_M"» -> «absGrpEnd.getName + "_E"» [style=invis]
		«ENDIF»
	'''
	
	
	/* **Methods for concrete patterns** */
	// Using normal style (black lines) for every element inside of it
	
	/**
	 * Generates the DOT code for a concrete Pattern
	 */
	/*
	 * Second IF Statement: generates the DOT code for a System inside a Concrete Pattern.
	 *						There will be a node containing the name of the Concrete System
	 * 						and its Abstract System as label of that node.
	 */
	private def getDotConcrSubgraph(Pattern it) '''
		subgraph cluster_concrete {
			label="«getName»"
			
			«IF getGroups !== null»
				«FOR concrGroups : getGroups»
					«concrGroups.getDotConcrGroups»
				«ENDFOR»
			«ENDIF»
			
			«IF getManagedSystems !== null»
				ConcrSys [shape=record style=filled width=2 «getDotConcrSysLabel»
			«ENDIF»
		}
	'''
	
	/**
	 * Generates the label for the Systems inside a Concrete Pattern.
	 *
	 */
	/*
	 * Example:
	 * PatternSysName1::AbsSysName1 PatternSysName2::AbsSysName2.
	 * It is necessary to have two FOR loops in one line in order
	 * to obtain a correct label for the Concrete System.
	 */
	// best previous solution:
	// label="«FOR managedConcrSys : getManagedSystems»«managedConcrSys.getName»::«managedConcrSys.getAbsSys.getName» «ENDFOR»"]
	private def getDotConcrSysLabel(Pattern it)'''
		label=«concrSysLabelValue»
	'''
	
	private def concrSysLabelValue(Pattern it) {
		// get first System's name (in Pattern)
		// and first Abstract System's name (in AbstractPattern)
		val first = getManagedSystems.get(0)
		val firstName = first.getName
		val firstBind = first.getAbsSys
		val firstBindName = firstBind.getName
		// variables that will contain all the names for Systems and
		// Abstract Systems, except first element of them
		var sysNames = newArrayList()
		var absSysNames = newArrayList()
		// value that the label in DOT code must contain
		var fullLabelValue=''
		
		if(getManagedSystems.size == 1)
			fullLabelValue = '"' + firstName + '::' + firstBindName + '"]'
		else if (getManagedSystems.size > 1) {
			for(i: 1..<getManagedSystems.size) {
				var sysBind = getManagedSystems.get(i)
				sysNames.add(sysBind.getName)
				absSysNames.add(sysBind.getAbsSys.getName)
			}
			fullLabelValue = '"' + firstName + '::' + firstBindName
			for(sysName : sysNames) {
				for(absSysName : absSysNames)
					fullLabelValue += '| ' + sysName + '::' + absSysName
			}
			fullLabelValue += '"]'
		}
		return fullLabelValue
	}
	
	/**
	 * Generates the DOT code for a Group inside a Concrete Pattern
	 */
	/*
	 * Example:
	 * grp1 [... label="grp1:absGrp1"]
	 */
	private def getDotConcrGroups(GroupBinding it)'''
		«val absGrpName = getAbsGroup.getName»
		«getName» [shape=rectangle style=rounded width=2 label="«getName»::«absGrpName»"]
	'''
	
	
	/* **Methods for configurations** */
	// Using blue style for every element inside of it to distinguish from the previous patterns.
	
	/**
	 * Generates the DOT code for a Configuration
	 */
	private def getDotConfigSubgraph(Configuration it)'''
		subgraph cluster_model {
			label="«getName»"
			edge [color=blue]
			color=blue
			
			«IF getConcreteSystems !== null»
				ConfigSys [shape=record style=filled width=2 «getDotConfigSysLabel»
			«ENDIF»
			
			«IF getConcreteGroups !== null»
				«FOR concrGrp : getConcreteGroups»
					«concrGrp.getDotConfigGroups»
				«ENDFOR»
			«ENDIF»
			
			«IF getConcreteInteractions !== null»
				«FOR concrIntr : getConcreteInteractions»
					«concrIntr.getDotConfigInteractions»
				«ENDFOR»
			«ENDIF»
		}
	'''
	
	/**
	 * Generates the DOT code for a System in Configuration
	 */
	/*
	 * It is necessary to have two FOR loops in one line to obtain a
	 * correct DOT line of code. Otherwise this will take to a
	 * multiline label and DOT won't recognize it.
	 */
	// best previous solution:
	// label="«FOR concrSys : getConcreteSystems»|«concrSys.getName»::«FOR sysBind : concrSys.getBindings»«sysBind.getName»«ENDFOR» «ENDFOR»"]
	private def getDotConfigSysLabel(Configuration it)'''
		label=«configSysLabelValue»
	'''
	
	private def configSysLabelValue(Configuration it) {
		// get first Concrete System's name (in Configuration)
		// and first System Binding's name (in Pattern)
		val first = getConcreteSystems.get(0)
		val firstName = first.getName
		val firstBind = first.getBindings.get(0)
		val firstBindName = firstBind.getName
		// variables that will contain all the names for Concrete Systems and
		// System Bindings, except first element of them
		var concrSysNames = newArrayList()
		var concrSysBindNames = newArrayList()
		// value that the label in DOT code must contain
		var fullLabelValue = ''
		
		if (getConcreteSystems.size == 1)
			fullLabelValue = '"' + firstName + '::' + firstBindName + '"]'
		else if (getConcreteSystems.size > 1) {
			for(i : 1..<getConcreteSystems.size) {
				concrSysNames.add(getConcreteSystems.get(i).getName)
				for(sysBind : getConcreteSystems.get(i).getBindings)
					concrSysBindNames.add(sysBind.getName)
			}
			fullLabelValue = '"' + firstName + '::' + firstBindName
			for(bindName : concrSysBindNames) {
				for(concrName : concrSysNames)
					fullLabelValue += '| ' + concrName + '::' + bindName
			}
			fullLabelValue += '"]'
		}
		return fullLabelValue
	}
	
	/** 
	 * Generates the DOT code for a Group in Configuration
	 */
	private def getDotConfigGroups(ConcreteGroup it)'''
		subgraph cluster_«getName» {
			label="«getName»::«FOR grpBind : getAbstractGroups»«grpBind.getName»«ENDFOR»"
			node [color=blue]
			color=blue
			«IF getComponents !== null»
				«FOR configComp : getComponents»
					«getName + "_" + configComp.getDotConfigComponents»
				«ENDFOR»
			«ENDIF»
		}
	'''
	
	/**
	 * Generates the DOT code for a Component in Configuration
	 */
	/*
	 * Example:
	 * m_ff [label="m_ff:M"]
	 */
	private def getDotConfigComponents(ComponentInstance it)'''
		«getName» [label="«getName»::«getType»"]
	'''
	
	/** 
	 * Generates the DOT code for an Interaction in Configuration
	 */
	/*
	 * First IF Statement: edge between nodes of different groups need
	 * 					   attribute CONSTRAINT for better visualization.
	 * Second IF Statement: adding an edge between ManagedSystem and M component.
	 * Third IF Statement: addition of a "false" interaction between M and
	 * 					   E for layout (specially in the Master-Slave case)
	 *					   This is set to invisible because there is no actual 
	 *					   interaction between component M and E.
	 */
	private def getDotConfigInteractions(Interaction it)'''
		«val compStart = getStart.getComponent»
		«val grpStart = compStart.eContainer as ConcreteGroup»
		«val compEnd = getEnd.getComponent»
		«val grpEnd = compEnd.eContainer as ConcreteGroup»
		«grpStart.getName + "_" + compStart.getName» -> «grpEnd.getName + "_" + compEnd.getName»
		«IF grpStart !== grpEnd»
			[constraint=false]
		«ENDIF»
		«IF compStart.getType == 'M'»
			ConfigSys -> «grpStart.getName + "_" + compStart.getName»
			[arrowhead=box lhead=cluster_«grpStart.getName» constraint=false]
		«ELSEIF compEnd.getType == 'M'»
			ConfigSys -> «grpEnd.getName + "_" + compEnd.getName»
			[arrowhead=box lhead=cluster_«grpEnd.getName» constraint=false]
		«ENDIF»
		«IF compStart.getType == 'M'»
			«grpStart.getName + "_" + compStart.getName» -> «grpStart.getName + "_" + compStart.getName.replace("m","e")» [style=invis]
		«ELSEIF compEnd.getType == 'M'»
			«grpEnd.getName + "_" + compEnd.getName» -> «grpEnd.getName + "_" + compStart.getName.replace("m","e")» [style=invis]
		«ENDIF»
	'''
	
	/**
	 * Creates DOT file's name to be saved into src-gen folder
	 */
	/*
	 * Example: if Resource file is "name.msl", this method will create
	 * a new file named "name.dot" containing all the DOT code.
	 */
	private def fileName(Resource res) {
		res.URI.lastSegment.replace("msl", "dot")
	}
	
}
